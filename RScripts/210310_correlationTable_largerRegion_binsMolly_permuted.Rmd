---
title: "Correlation tables: permuted"
author: "Koen Van den Berge"
date: "3/10/2021"
output: html_document
---

```{r}
library(dayjob) #https://github.com/koenvandenberge/dayjob
library(data.table)
library(tidyverse)
library(pheatmap)
library(RColorBrewer)
time <- c("0 min", "5 min", "15 min", "45 min", "90 min", "150 min")
```


# Probability relatively to max methylation

## HMR

```{r}
hmrE <- 292674:292769
hmrI <- 294805:294864
  
chr3Files <- list.files("/Users/koenvandenberge/data/molly/Rescue",
                        pattern = "^chrIII", full.names = TRUE)

for(ff in 1:length(chr3Files)){
  binaryCalls <- fread(file = chr3Files[ff])
  colnames(binaryCalls) <- c("readID", "chr", "strand", "pos",
                             "mod_log_prob", "can_log_prob", "mod_base")
  binaryCalls$methylation <- ifelse(binaryCalls$mod_log_prob > -0.2231436, 1, 0)
  binaryCalls <- binaryCalls[,c("readID", "chr", "strand", 
                                "pos", "methylation")]

  
  ## subset reads that completely overlap HMR
  readCalls <- binaryCalls %>% 
    group_by(readID) %>%
    summarize(start=min(pos),
              end=max(pos),
              avgMeth = mean(methylation),
              length = n())
  readsHMR <- unique(readCalls$readID[readCalls$start <= (min(hmrE) - 500) & 
                                  readCalls$end >= (max(hmrI) + 500)])
  assign(paste0("binaryCalls",ff), binaryCalls[binaryCalls$readID %in% readsHMR,])
}
```

# Non-permuted correlation

```{r}
permute <- FALSE
rmNA <- TRUE #should reads with no data at some segments be removed?
# make probability matrix: relative to max avg methylation in each bin.
### HMR segments
hmrSegments <- readRDS("../data/HMR_bins.rds")
readAvMethListHMR <- list()
for(ff in 1:length(chr3Files)){ # loop timepoints
  curData <- get(paste0("binaryCalls",ff))
  curReads <- unique(curData$readID)
  for(rr in 1:length(curReads)){ # loop reads
    curRead <- curReads[rr]
    curReadData <- curData[curData$readID == curRead,]
    avMethLinkers <- c()
    for(bb in 1:nrow(hmrSegments)){ # loop bins
      curStart <- hmrSegments$start[bb]
      curEnd <- hmrSegments$end[bb]
      curId <- curReadData$pos >= curStart & curReadData$pos <= curEnd
      if(sum(curId) > 0){
        curBinData <- curReadData[curReadData$pos >= curStart & curReadData$pos <= curEnd,]
        avMethLinkers[bb] <- mean(curBinData$methylation)
        names(avMethLinkers)[bb] <- nrow(curBinData) #coverage
      } else {
        avMethLinkers[bb] <- NA
      }
    }
    readAvMethListHMR[[rr]] <- avMethLinkers
  }
  avMethMatHMR <- do.call(rbind, readAvMethListHMR)
  if(rmNA){
    if(sum(is.na(avMethMatHMR)) > 0){
      matNaId <- dayjob::elementToRowCol(which(is.na(avMethMatHMR)), nrow(avMethMatHMR), ncol(avMethMatHMR))
      if(is(matNaId, "matrix")){
        rowsWithNA <- unique(matNaId[,"row"])
      } else if(is(matNaId, "vector")){
        rowsWithNA <- matNaId[1]
      }
    avMethMatHMR <- avMethMatHMR[-rowsWithNA,]
    }
  }
  if(permute){
    for(rr in 1:nrow(avMethMatHMR)) avMethMatHMR[rr,] <- avMethMatHMR[rr,sample(ncol(avMethMatHMR))]
  }
  # normalize by maximum average methylation in each bin
  avMethMatHMRNormalizedPerBin <- sweep(avMethMatHMR, 2, STATS=apply(avMethMatHMR, 2, max, na.rm=TRUE), FUN="/")
    avMethMatHMRNormalizedAll <- avMethMatHMR / max(avMethMatHMR, na.rm=TRUE)
  assign(paste0("avMethMatHMRNormalizedAll", ff), avMethMatHMRNormalizedAll)
  assign(paste0("avMethMatHMRNormalizedPerBin", ff), avMethMatHMRNormalizedPerBin)
}


pheatmap(cor(avMethMatHMRNormalizedAll1), 
         cluster_rows = FALSE, cluster_cols=FALSE)
pheatmap(cor(avMethMatHMRNormalizedAll2), 
         cluster_rows = FALSE, cluster_cols=FALSE)
pheatmap(cor(avMethMatHMRNormalizedAll3), 
         cluster_rows = FALSE, cluster_cols=FALSE)
pheatmap(cor(avMethMatHMRNormalizedAll4), 
         cluster_rows = FALSE, cluster_cols=FALSE)
pheatmap(cor(avMethMatHMRNormalizedAll5), 
         cluster_rows = FALSE, cluster_cols=FALSE)
pheatmap(cor(avMethMatHMRNormalizedAll6), 
         cluster_rows = FALSE, cluster_cols=FALSE)
```

# Permuted correlation

```{r}
permute <- TRUE
rmNA <- TRUE #should reads with no data at some segments be removed?
# make probability matrix: relative to max avg methylation in each bin.
### HMR segments
hmrSegments <- readRDS("../data/HMR_bins.rds")
readAvMethListHMR <- list()
for(ff in 1:length(chr3Files)){ # loop timepoints
  curData <- get(paste0("binaryCalls",ff))
  curReads <- unique(curData$readID)
  for(rr in 1:length(curReads)){ # loop reads
    curRead <- curReads[rr]
    curReadData <- curData[curData$readID == curRead,]
    avMethLinkers <- c()
    for(bb in 1:nrow(hmrSegments)){ # loop bins
      curStart <- hmrSegments$start[bb]
      curEnd <- hmrSegments$end[bb]
      curId <- curReadData$pos >= curStart & curReadData$pos <= curEnd
      if(sum(curId) > 0){
        curBinData <- curReadData[curReadData$pos >= curStart & curReadData$pos <= curEnd,]
        avMethLinkers[bb] <- mean(curBinData$methylation)
        names(avMethLinkers)[bb] <- nrow(curBinData) #coverage
      } else {
        avMethLinkers[bb] <- NA
      }
    }
    readAvMethListHMR[[rr]] <- avMethLinkers
  }
  avMethMatHMR <- do.call(rbind, readAvMethListHMR)
  if(rmNA){
    if(sum(is.na(avMethMatHMR)) > 0){
      matNaId <- dayjob::elementToRowCol(which(is.na(avMethMatHMR)), nrow(avMethMatHMR), ncol(avMethMatHMR))
      if(is(matNaId, "matrix")){
        rowsWithNA <- unique(matNaId[,"row"])
      } else if(is(matNaId, "vector")){
        rowsWithNA <- matNaId[1]
      }
    avMethMatHMR <- avMethMatHMR[-rowsWithNA,]
    }
  }
  if(permute){
    for(rr in 1:nrow(avMethMatHMR)) avMethMatHMR[rr,] <- avMethMatHMR[rr,sample(ncol(avMethMatHMR))]
  }
  # normalize by maximum average methylation in each bin
  avMethMatHMRNormalizedPerBin <- sweep(avMethMatHMR, 2, STATS=apply(avMethMatHMR, 2, max, na.rm=TRUE), FUN="/")
    avMethMatHMRNormalizedAll <- avMethMatHMR / max(avMethMatHMR, na.rm=TRUE)
  assign(paste0("avMethMatHMRNormalizedAll", ff), avMethMatHMRNormalizedAll)
  assign(paste0("avMethMatHMRNormalizedPerBin", ff), avMethMatHMRNormalizedPerBin)
}


pheatmap(cor(avMethMatHMRNormalizedAll1), 
         cluster_rows = FALSE, cluster_cols=FALSE)
pheatmap(cor(avMethMatHMRNormalizedAll2), 
         cluster_rows = FALSE, cluster_cols=FALSE)
pheatmap(cor(avMethMatHMRNormalizedAll3), 
         cluster_rows = FALSE, cluster_cols=FALSE)
pheatmap(cor(avMethMatHMRNormalizedAll4), 
         cluster_rows = FALSE, cluster_cols=FALSE)
pheatmap(cor(avMethMatHMRNormalizedAll5), 
         cluster_rows = FALSE, cluster_cols=FALSE)
pheatmap(cor(avMethMatHMRNormalizedAll6), 
         cluster_rows = FALSE, cluster_cols=FALSE)
```

