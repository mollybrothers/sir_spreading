---
title: "Conditional methylation probability tables using Molly's bins: Russula run"
author: "Koen Van den Berge"
date: "3/10/2021"
output: html_document
---

```{r}
library(data.table)
library(tidyverse)
```


# Probability relatively to max methylation

## HMR

```{r}
hmrE <- 292674:292769
hmrI <- 294805:294864
  
chr3Files <- list.files("/Users/koenvandenberge/data/molly/Russula",
                        pattern = "^chrIII", full.names = TRUE)

for(ff in 1:length(chr3Files)){
  binaryCalls <- fread(file = chr3Files[ff])
  colnames(binaryCalls) <- c("readID", "chr", "strand", "pos",
                             "mod_log_prob", "can_log_prob", "mod_base")
  binaryCalls$methylation <- ifelse(binaryCalls$mod_log_prob > -0.2231436, 1, 0)
  binaryCalls <- binaryCalls[,c("readID", "chr", "strand", 
                                "pos", "methylation")]

  
  ## subset reads that completely overlap HMR
  readCalls <- binaryCalls %>% 
    group_by(readID) %>%
    summarize(start=min(pos),
              end=max(pos),
              avgMeth = mean(methylation),
              length = n())
  readsHMR <- unique(readCalls$readID[readCalls$start <= (min(hmrE) - 500) & 
                                  readCalls$end >= (max(hmrI) + 500)])
  assign(paste0("binaryCalls",ff), binaryCalls[binaryCalls$readID %in% readsHMR,])
}
```


```{r}
# make probability matrix: relative to max avg methylation in each bin.
### HMR segments
hmrSegments <- readRDS("../data/HMR_bins.rds")
readAvMethListHMR <- list()
for(ff in 1:length(chr3Files)){ # loop timepoints
  curData <- get(paste0("binaryCalls",ff))
  curReads <- unique(curData$readID)
  for(rr in 1:length(curReads)){ # loop reads
    curRead <- curReads[rr]
    curReadData <- curData[curData$readID == curRead,]
    avMethLinkers <- c()
    for(bb in 1:nrow(hmrSegments)){ # loop bins
      curStart <- hmrSegments$start[bb]
      curEnd <- hmrSegments$end[bb]
      curId <- curReadData$pos >= curStart & curReadData$pos <= curEnd
      if(sum(curId) > 0){
        curBinData <- curReadData[curReadData$pos >= curStart & curReadData$pos <= curEnd,]
        avMethLinkers[bb] <- mean(curBinData$methylation)
        names(avMethLinkers)[bb] <- nrow(curBinData) #coverage
      } else {
        avMethLinkers[bb] <- NA
      }
    }
    readAvMethListHMR[[rr]] <- avMethLinkers
  }
  avMethMatHMR <- do.call(rbind, readAvMethListHMR)
  # normalize by maximum average methylation in each bin
  avMethMatHMRNormalizedPerBin <- sweep(avMethMatHMR, 2, STATS=apply(avMethMatHMR, 2, max, na.rm=TRUE), FUN="/")
  avMethMatHMRNormalizedAll <- avMethMatHMR / max(avMethMatHMR, na.rm=TRUE)
  assign(paste0("avMethMatHMR", ff), avMethMatHMR)
  assign(paste0("avMethMatHMRNormalizedAll", ff), avMethMatHMRNormalizedAll)
  assign(paste0("avMethMatHMRNormalizedPerBin", ff), avMethMatHMRNormalizedPerBin)
}
```

## No normalization

```{r}
for(ff in 1:length(chr3Files)){
  #if(ff == 4) next
  curMeth <- get(paste0("avMethMatHMR", ff))
  conditionalProbability <- matrix(NA, nrow=nrow(hmrSegments), ncol=nrow(hmrSegments))
  for(bb in 1:nrow(hmrSegments)){
    jointProbability <- colMeans(curMeth[,bb] * curMeth, na.rm=TRUE) # P(bin A, bin B)
    # P(bin A | bin B) = P(bin A, bin B) / P(bin B)
    conditionalProbability[,bb] <- jointProbability / (colMeans(curMeth, na.rm=TRUE)+1e-3)
  }
  # jointProbability <- crossprod(curMeth) / nrow(curMeth)
  # # P(A)
  # marginalProbability <- colMeans(curMeth)
  # # P(A=1 | B=1) = P(A=1, B=1) / P(B=1)
  # # P(B=1 | A=1) = P(A=1, B=1) / P(A=1)
  # conditionalProbability <- jointProbability / marginalProbability
  
  time <- c("0 min", "15 min", "30 min", "45 min", "60 min", "90 min")
  library(pheatmap)
  library(RColorBrewer)
  colpal <- colorRampPalette(rev(brewer.pal(n = 7, name="RdYlBu")))(100)
  breaks <- c(seq(0.05, 0.7, length=100), .8)
  rownames(conditionalProbability) <- paste0("P(. | bin", 1:nrow(hmrSegments),")")
  colnames(conditionalProbability) <- paste0("P(bin", 1:nrow(hmrSegments)," | .)")
  pheatmap(conditionalProbability,
           cluster_rows = FALSE,
           cluster_cols=FALSE,
           main=paste0("HMR: ", time[ff]),
           col = colpal, breaks = breaks)
  assign(paste0("conditionalProbabilityTable", ff), conditionalProbability)
}
```



## Normalize across all

```{r}
for(ff in 1:length(chr3Files)){
  #if(ff == 4) next
  curMeth <- get(paste0("avMethMatHMRNormalizedAll", ff))
  conditionalProbability <- matrix(NA, nrow=nrow(hmrSegments), ncol=nrow(hmrSegments))
  for(bb in 1:nrow(hmrSegments)){
    jointProbability <- colMeans(curMeth[,bb] * curMeth, na.rm=TRUE) # P(bin A, bin B)
    # P(bin A | bin B) = P(bin A, bin B) / P(bin B)
    conditionalProbability[,bb] <- jointProbability / (colMeans(curMeth, na.rm=TRUE)+1e-3)
  }
  # jointProbability <- crossprod(curMeth) / nrow(curMeth)
  # # P(A)
  # marginalProbability <- colMeans(curMeth)
  # # P(A=1 | B=1) = P(A=1, B=1) / P(B=1)
  # # P(B=1 | A=1) = P(A=1, B=1) / P(A=1)
  # conditionalProbability <- jointProbability / marginalProbability
  
  time <- c("0 min", "15 min", "30 min", "45 min", "60 min", "90 min")
  library(pheatmap)
  library(RColorBrewer)
  colpal <- colorRampPalette(rev(brewer.pal(n = 7, name="RdYlBu")))(100)
  breaks <- c(0, seq(0.05, 0.7, length=99), .8)
  rownames(conditionalProbability) <- paste0("P(. | bin", 1:nrow(hmrSegments),")")
  colnames(conditionalProbability) <- paste0("P(bin", 1:nrow(hmrSegments)," | .)")
  pheatmap(conditionalProbability,
           cluster_rows = FALSE,
           cluster_cols=FALSE,
           main=paste0("HMR: ", time[ff]),
           col = colpal, breaks = breaks)
  assign(paste0("conditionalProbabilityTable", ff), conditionalProbability)
}

# should this be correlated?
plot(x=colMeans(avMethMatHMRNormalizedAll1), y=diag(conditionalProbabilityTable1))
```


## Normalize per bin

```{r}
for(ff in 1:length(chr3Files)){
  #if(ff == 4) next
  curMeth <- get(paste0("avMethMatHMRNormalizedPerBin", ff))
  conditionalProbability <- matrix(NA, nrow=nrow(hmrSegments), ncol=nrow(hmrSegments))
  for(bb in 1:nrow(hmrSegments)){
    jointProbability <- colMeans(curMeth[,bb] * curMeth, na.rm=TRUE) # P(bin A, bin B)
    # P(bin A | bin B) = P(bin A, bin B) / P(bin B)
    conditionalProbability[,bb] <- jointProbability / (colMeans(curMeth, na.rm=TRUE)+1e-3)
  }
  # jointProbability <- crossprod(curMeth) / nrow(curMeth)
  # # P(A)
  # marginalProbability <- colMeans(curMeth)
  # # P(A=1 | B=1) = P(A=1, B=1) / P(B=1)
  # # P(B=1 | A=1) = P(A=1, B=1) / P(A=1)
  # conditionalProbability <- jointProbability / marginalProbability
  
  time <- c("0 min", "15 min", "30 min", "45 min", "60 min", "90 min")
  library(pheatmap)
  library(RColorBrewer)
  colpal <- colorRampPalette(rev(brewer.pal(n = 7, name="RdYlBu")))(100)
  breaks <- c(0, seq(0.05, 0.7, length=99), .8)
  rownames(conditionalProbability) <- paste0("P(. | bin", 1:nrow(hmrSegments),")")
  colnames(conditionalProbability) <- paste0("P(bin", 1:nrow(hmrSegments)," | .)")
  pheatmap(conditionalProbability,
           cluster_rows = FALSE,
           cluster_cols=FALSE,
           main=paste0("HMR: ", time[ff]),
           col = colpal, breaks = breaks)
  assign(paste0("conditionalProbabilityTable", ff), conditionalProbability)
}

# should this be correlated?
plot(x=colMeans(avMethMatHMRNormalizedPerBin1), y=diag(conditionalProbabilityTable1))



```


## HML

```{r}
hmlE <- 11237:11268
hmlI <- 14600:14711
  
chr3Files <- list.files("/Users/koenvandenberge/data/molly/Russula",
                        pattern = "^chrIII", full.names = TRUE)

for(ff in 1:length(chr3Files)){
  binaryCalls <- fread(file = chr3Files[ff])
  colnames(binaryCalls) <- c("readID", "chr", "strand", "pos",
                             "mod_log_prob", "can_log_prob", "mod_base")
  binaryCalls$methylation <- ifelse(binaryCalls$mod_log_prob > -0.2231436, 1, 0)
  binaryCalls <- binaryCalls[,c("readID", "chr", "strand", 
                                "pos", "methylation")]

  
  ## subset reads that completely overlap HMR
  readCalls <- binaryCalls %>% 
    group_by(readID) %>%
    summarize(start=min(pos),
              end=max(pos),
              avgMeth = mean(methylation),
              length = n())
  readsHMR <- unique(readCalls$readID[readCalls$start <= (min(hmlE) - 500) & 
                                  readCalls$end >= (max(hmlI) + 500)])
  assign(paste0("binaryCalls",ff), binaryCalls[binaryCalls$readID %in% readsHMR,])
}
```

```{r}
# make probability matrix: relative to max avg methylation in each bin.
### HML segments
HMLSegments <- readRDS("../data/HML_bins.rds")
readAvMethListHML <- list()
for(ff in 1:length(chr3Files)){ # loop timepoints
  curData <- get(paste0("binaryCalls",ff))
  curReads <- unique(curData$readID)
  for(rr in 1:length(curReads)){ # loop reads
    curRead <- curReads[rr]
    curReadData <- curData[curData$readID == curRead,]
    avMethLinkers <- c()
    for(bb in 1:nrow(HMLSegments)){ # loop bins
      curStart <- HMLSegments$start[bb]
      curEnd <- HMLSegments$end[bb]
      curId <- curReadData$pos >= curStart & curReadData$pos <= curEnd
      if(sum(curId) > 0){
        curBinData <- curReadData[curReadData$pos >= curStart & curReadData$pos <= curEnd,]
        avMethLinkers[bb] <- mean(curBinData$methylation)
        names(avMethLinkers)[bb] <- nrow(curBinData) #coverage
      } else {
        avMethLinkers[bb] <- NA
      }
    }
    readAvMethListHML[[rr]] <- avMethLinkers
  }
  avMethMatHML <- do.call(rbind, readAvMethListHML)
  # normalize by maximum average methylation in each bin
  avMethMatHMLNormalizedPerBin <- sweep(avMethMatHML, 2, STATS=apply(avMethMatHML, 2, max, na.rm=TRUE), FUN="/")
  avMethMatHMLNormalizedAll <- avMethMatHML / max(avMethMatHML, na.rm=TRUE)
  assign(paste0("avMethMatHML", ff), avMethMatHML)
  assign(paste0("avMethMatHMLNormalizedAll", ff), avMethMatHMLNormalizedAll)
  assign(paste0("avMethMatHMLNormalizedPerBin", ff), avMethMatHMLNormalizedPerBin)
}

# for(ff in 1:length(chr3Files)){
#   curMeth <- get(paste0("avMethMatHMLNormalized", ff))
#   jointProbability <- crossprod(curMeth) / nrow(curMeth)
#   # P(A)
#   marginalProbability <- colMeans(curMeth)
#   # P(A=1 | B=1) = P(A=1, B=1) / P(B=1)
#   # P(B=1 | A=1) = P(A=1, B=1) / P(A=1)
#   conditionalProbability <- jointProbability / marginalProbability
#   
#   library(pheatmap)
#   pheatmap(conditionalProbability,
#            cluster_rows = FALSE,
#            cluster_cols=FALSE,
#            main=paste0("Conditional probability Table ", ff))
#   assign(paste0("conditionalProbabilityTable", ff), conditionalProbability)
# }
```


## No normalization

```{r}
for(ff in 1:length(chr3Files)){
  #if(ff == 4) next
  curMeth <- get(paste0("avMethMatHML", ff))
  conditionalProbability <- matrix(NA, nrow=nrow(HMLSegments), ncol=nrow(HMLSegments))
  for(bb in 1:nrow(HMLSegments)){
    jointProbability <- colMeans(curMeth[,bb] * curMeth, na.rm=TRUE) # P(bin A, bin B)
    # P(bin A | bin B) = P(bin A, bin B) / P(bin B)
    conditionalProbability[,bb] <- jointProbability / (colMeans(curMeth, na.rm=TRUE)+1e-3)
    #avConditionalProbability <- colMeans(conditionalProbability)
  }
  # jointProbability <- crossprod(curMeth) / nrow(curMeth)
  # # P(A)
  # marginalProbability <- colMeans(curMeth)
  # # P(A=1 | B=1) = P(A=1, B=1) / P(B=1)
  # # P(B=1 | A=1) = P(A=1, B=1) / P(A=1)
  # conditionalProbability <- jointProbability / marginalProbability
  time <- c("0 min", "15 min", "30 min", "45 min", "60 min", "90 min")
  library(pheatmap)
  library(RColorBrewer)
  colpal <- colorRampPalette(rev(brewer.pal(n = 7, name="RdYlBu")))(100)
  breaks <- c(0, seq(0.05, 0.7, length=99), .8)
  rownames(conditionalProbability) <- paste0("P(. | bin", 1:nrow(HMLSegments),")")
  colnames(conditionalProbability) <- paste0("P(bin", 1:nrow(HMLSegments)," | .)")
  pheatmap(conditionalProbability,
           cluster_rows = FALSE,
           cluster_cols=FALSE,
           main=paste0("HML: ", time[ff]),
           col = colpal, breaks = breaks)
  assign(paste0("conditionalProbabilityTable", ff), conditionalProbability)
}

```

## Normalize across all

```{r}
for(ff in 1:length(chr3Files)){
  #if(ff == 4) next
  curMeth <- get(paste0("avMethMatHMLNormalizedAll", ff))
  conditionalProbability <- matrix(NA, nrow=nrow(HMLSegments), ncol=nrow(HMLSegments))
  for(bb in 1:nrow(HMLSegments)){
    jointProbability <- colMeans(curMeth[,bb] * curMeth, na.rm=TRUE) # P(bin A, bin B)
    # P(bin A | bin B) = P(bin A, bin B) / P(bin B)
    conditionalProbability[,bb] <- jointProbability / (colMeans(curMeth, na.rm=TRUE)+1e-3)
    #avConditionalProbability <- colMeans(conditionalProbability)
  }
  # jointProbability <- crossprod(curMeth) / nrow(curMeth)
  # # P(A)
  # marginalProbability <- colMeans(curMeth)
  # # P(A=1 | B=1) = P(A=1, B=1) / P(B=1)
  # # P(B=1 | A=1) = P(A=1, B=1) / P(A=1)
  # conditionalProbability <- jointProbability / marginalProbability
  time <- c("0 min", "15 min", "30 min", "45 min", "60 min", "90 min")
  library(pheatmap)
  library(RColorBrewer)
  colpal <- colorRampPalette(rev(brewer.pal(n = 7, name="RdYlBu")))(100)
  breaks <- c(0, seq(0.05, 0.7, length=99), .8)
  rownames(conditionalProbability) <- paste0("P(. | bin", 1:nrow(HMLSegments),")")
  colnames(conditionalProbability) <- paste0("P(bin", 1:nrow(HMLSegments)," | .)")
  pheatmap(conditionalProbability,
           cluster_rows = FALSE,
           cluster_cols=FALSE,
           main=paste0("HML: ", time[ff]),
           col = colpal, breaks = breaks)
  assign(paste0("conditionalProbabilityTable", ff), conditionalProbability)
}

# should this be correlated?
plot(x=colMeans(avMethMatHMLNormalizedAll1), y=diag(conditionalProbabilityTable1))
```

## Normalize per bin

```{r}
for(ff in 1:length(chr3Files)){
  #if(ff == 4) next
  curMeth <- get(paste0("avMethMatHMLNormalizedPerBin", ff))
  conditionalProbability <- matrix(NA, nrow=nrow(HMLSegments), ncol=nrow(HMLSegments))
  for(bb in 1:nrow(HMLSegments)){
    jointProbability <- colMeans(curMeth[,bb] * curMeth, na.rm=TRUE) # P(bin A, bin B)
    # P(bin A | bin B) = P(bin A, bin B) / P(bin B)
    conditionalProbability[,bb] <- jointProbability / (colMeans(curMeth, na.rm=TRUE)+1e-3)
    #avConditionalProbability <- colMeans(conditionalProbability)
  }
  # jointProbability <- crossprod(curMeth) / nrow(curMeth)
  # # P(A)
  # marginalProbability <- colMeans(curMeth)
  # # P(A=1 | B=1) = P(A=1, B=1) / P(B=1)
  # # P(B=1 | A=1) = P(A=1, B=1) / P(A=1)
  # conditionalProbability <- jointProbability / marginalProbability
  time <- c("0 min", "15 min", "30 min", "45 min", "60 min", "90 min")
  library(pheatmap)
  library(RColorBrewer)
  colpal <- colorRampPalette(rev(brewer.pal(n = 7, name="RdYlBu")))(100)
  breaks <- c(0, seq(0.05, 0.7, length=99), .8)
  rownames(conditionalProbability) <- paste0("P(. | bin", 1:nrow(HMLSegments),")")
  colnames(conditionalProbability) <- paste0("P(bin", 1:nrow(HMLSegments)," | .)")
  pheatmap(conditionalProbability,
           cluster_rows = FALSE,
           cluster_cols=FALSE,
           main=paste0("HML: ", time[ff]),
           col = colpal, breaks = breaks)
  assign(paste0("conditionalProbabilityTable", ff), conditionalProbability)
}

# should this be correlated?
plot(x=colMeans(avMethMatHMLNormalizedPerBin1), y=diag(conditionalProbabilityTable1))
```


