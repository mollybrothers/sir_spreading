---
title: 'Cracking the SIR spreading code: preliminary ideas'
author: "Koen Van den Berge"
date: "3/13/2021"
output: html_document
---

# Data simulation

Here we will simulate data where there are four bins, and a pre-defined logic. The true logic is the following:

 - **No methylation**: Bin 1 is methylated with 85% probability. Alternatively, other bins are methylated with a 5% probability each.
 - **One bin methylated**: Given bin 1 is methylated, bin 4 is methylated with 70% probability, and 10% probability for each other bin. If another bin is methylated, one of the other three bins is selected randomly (hence with a 33% probability).
 - **Two bins methylated**: If bin 1 and bin 4 are methylated, bin 2 is methylated with 80% probability, and therefore bin 3 is methylated with 20% probability. If not, another bin will be methylated randomly.
 - **Three bins methylated**: There is only one option, which is methylation of the remaining bin.
 
```{r}
simulateOneRead <- function(){
  data <- rep(0, 4)
  ## first bin
  bin1Sample <- rbinom(n = 1, size = 1, prob = 0.85)
  if(bin1Sample){
    data[1] <- 1
  } else {
    data[sample(x=2:4, size=1)] <- 1
  }
  data1 <- data
  
  ## second bin
  bin2Sample <- rbinom(n = 1, size = 1, prob = 0.70)
  if(bin1Sample & bin2Sample){
    data[4] <- 1
  } else {
    data[sample(x=which(data==0), size=1)] <- 1
  }
  data2 <- data
  
  ## third bin
  bin3Sample <- rbinom(n = 1, size = 1, prob = 0.80)
  if(bin1Sample & bin2Sample & bin3Sample){
    data[2] <- 1
  } else {
    data[sample(x=which(data==0), size=1)] <- 1
  }
  data3 <- data
  
  ## fourth bin
  data[sample(x=which(data==0), size=1)] <- 1
  data4 <- data
  
  return(rbind(data1, data2, data3, data4))
}

for(kk in 1:100){
  if(kk == 1){
    reads <- simulateOneRead()
  } else {
    reads <- rbind(reads, simulateOneRead())
  }
}


```
 
 

# Analysis ideas
 
## HMM

If we think about a Hidden Markov Model, then we would have $2^4 = 16$ different states. However the number of states scale exponentially with the number of bins. If we'd have 20 bins there would be $2^{20} = 1048576$ different states. This quickly makes a standard HMM approach infeasible.

## Latent semantic indexing and clustering

Here we consider each read as a data point, and the different bins as binary variables. The data then can be considered as NLP data. We can visualize the reads in reduced dimensional space using LSI, coloring reads by how many bins are methylated, and possibly interpret these plots.


```{r}

### Too few data points for LSI
# library(Seurat)
# lsi <- Seurat::RunLSI(t(reads), n=2)
# dr <- Seurat::Embeddings(lsi)


library(pheatmap)
pheatmap(reads, cluster_cols = FALSE)
pheatmap(reads[order(rowSums(reads)),], cluster_rows=FALSE, cluster_cols = FALSE)

for(kk in 1:3){
  curReads <- reads[rowSums(reads) == kk,]
  pheatmap(curReads, cluster_cols = FALSE)
}
```

### Turkey run: single-base level

```{r}
library(data.table)
library(tidyverse)
## try on real data
binaryCalls <- fread(file = "/Users/koenvandenberge/data/molly/megalodon_output_06/per_read_modified_base_calls_binary.txt.gz",
                     nrows = 6e6, skip=11e6)
colnames(binaryCalls) <- c("readID", "chr", "strand", "pos",
                           "mod_log_prob", "can_log_prob", "mod_base")
table(binaryCalls$chr)
binaryCalls$methylation <- ifelse(binaryCalls$mod_log_prob > -0.2231436, 1, 0)
binaryCalls3 <- binaryCalls[binaryCalls$chr == "III",]

hmrE <- 292674:292769
hmrI <- 294805:294864

## subset reads that completely overlap HMR
readCalls3 <- binaryCalls3 %>% 
  group_by(readID) %>%
  summarize(start=min(pos),
            end=max(pos),
            avgMeth = mean(methylation),
            length = n())
readsHMR <- unique(readCalls3$readID[readCalls3$start <= min(hmrE) & 
                                readCalls3$end >= max(hmrI)])
binaryCallsHMR <- binaryCalls3[binaryCalls3$readID %in% readsHMR,]

# make binary matrix
binaryMatrixHMR <- matrix(NA, nrow=length(readsHMR), ncol=max(hmrI) - min(hmrE))
colnames(binaryMatrixHMR) <- (min(hmrE)+1):max(hmrI)
for(rr in 1:length(readsHMR)){
  curRead <- readsHMR[rr]
  curData <- binaryCallsHMR[binaryCallsHMR$readID == curRead,]
  curData <- curData[(curData$pos > min(hmrE) & curData$pos < max(hmrI)),]
  binaryMatrixHMR[rr, curData$pos - min(hmrE)] <- curData$methylation
}
# rm columns with all NA
binaryMatrixHMR <- binaryMatrixHMR[,!colSums(is.na(binaryMatrixHMR)) == nrow(binaryMatrixHMR)]
binaryMatrixHMR <- binaryMatrixHMR[!rowSums(is.na(binaryMatrixHMR)) == ncol(binaryMatrixHMR),]
binaryMatrixHMRFull <- binaryMatrixHMR
binaryMatrixHMRFull[is.na(binaryMatrixHMRFull)] <- 0.5
library(pheatmap)
pheatmap(binaryMatrixHMRFull, 
         cluster_rows=TRUE, cluster_cols=FALSE,
         show_colnames = FALSE, show_rownames = FALSE)
pheatmap(binaryMatrixHMRFull[order(rowMeans(binaryMatrixHMR, na.rm=TRUE)),], 
         cluster_rows=FALSE, cluster_cols=FALSE,
         show_colnames = FALSE, show_rownames = FALSE)

## Reduced dimension
# library(Seurat)
# lsiHMRFull <- Seurat::RunLSI(t(binaryMatrixHMRFull), n=10)
# lsidr <- Embeddings(lsiHMRFull)
# plot(lsidr, 
#      col = dayjob::colby(rowMeans(binaryMatrixHMR, na.rm=TRUE)),
#      pch=16)
```

### Turkey run: HMR segment level


```{r}
### HMR segments
hmrSegments <- readRDS("../../data/segmentsHMR.rds")
readAvMethList <- list()
for(rr in 1:length(readsHMR)){
  curRead <- readsHMR[rr]
  curData <- binaryCallsHMR[binaryCallsHMR$readID == curRead,]
  avMethLinkers <- c()
  for(bb in 1:nrow(hmrSegments)){
    curStart <- hmrSegments$start[bb]
    curEnd <- hmrSegments$end[bb]
    curId <- curData$pos >= curStart & curData$pos <= curEnd
    if(sum(curId) > 0){
      curBinData <- curData[curData$pos >= curStart & curData$pos <= curEnd,]
      avMethLinkers[bb] <- mean(curBinData$methylation)
      names(avMethLinkers)[bb] <- nrow(curBinData) #coverage
    } else {
      avMethLinkers[bb] <- NA
    }
  }
  readAvMethList[[rr]] <- avMethLinkers
}

avMethMat <- do.call(rbind, readAvMethList)
colSums(is.na(avMethMat)) # sometimes no data in defined bins
# focus on 53 reads with data in all bins
readAvMethListComplete <- avMethMat[rowSums(is.na(avMethMat)) == 0,]

# cluster reads only
pheatmap(readAvMethListComplete, 
         cluster_rows=TRUE, cluster_cols=FALSE,
         show_colnames = FALSE, show_rownames = FALSE)
# cluster reads and bins
pheatmap(readAvMethListComplete, 
         cluster_rows=TRUE, cluster_cols=TRUE,
         show_colnames = FALSE, show_rownames = FALSE)
# order by mean
pheatmap(readAvMethListComplete[order(rowMeans(readAvMethListComplete)),], 
         cluster_rows=FALSE, cluster_cols=FALSE,
         show_colnames = FALSE, show_rownames = FALSE)
```

# Rescue run time-course

```{r}
hmrE <- 292674:292769
hmrI <- 294805:294864
  
chr3Files <- list.files("/Users/koenvandenberge/data/molly/Rescue",
                        pattern = "^chrIII", full.names = TRUE)

for(ff in 1:length(chr3Files)){
  binaryCalls <- fread(file = chr3Files[ff])
  colnames(binaryCalls) <- c("readID", "chr", "strand", "pos",
                             "mod_log_prob", "can_log_prob", "mod_base")
  binaryCalls$methylation <- ifelse(binaryCalls$mod_log_prob > -0.2231436, 1, 0)
  binaryCalls <- binaryCalls[,c("readID", "chr", "strand", 
                                "pos", "methylation")]

  
  ## subset reads that completely overlap HMR
  readCalls <- binaryCalls %>% 
    group_by(readID) %>%
    summarize(start=min(pos),
              end=max(pos),
              avgMeth = mean(methylation),
              length = n())
  readsHMR <- unique(readCalls$readID[readCalls$start <= min(hmrE) & 
                                  readCalls$end >= max(hmrI)])
  if(ff == 1){
    readsHMRAll <- readsHMR
    binaryCallsHMRAll <- binaryCalls[binaryCalls$readID %in% readsHMR,]
  } else {
    readsHMRAll <- c(readsHMRAll, readsHMR)
    binaryCallsHMRAll <- rbind(binaryCallsHMRAll, 
                               binaryCalls[binaryCalls$readID %in% readsHMR,])
  }
}

# make binary matrix
binaryMatrixHMRTurkey <- matrix(NA, nrow=length(readsHMRAll), ncol=max(hmrI) - min(hmrE))
colnames(binaryMatrixHMRTurkey) <- (min(hmrE)+1):max(hmrI)
for(rr in 1:length(readsHMRAll)){
  curRead <- readsHMRAll[rr]
  curData <- binaryCallsHMRAll[binaryCallsHMRAll$readID == curRead,]
  curData <- curData[(curData$pos > min(hmrE) & curData$pos < max(hmrI)),]
  binaryMatrixHMRTurkey[rr, curData$pos - min(hmrE)] <- curData$methylation
}
# rm columns with all NA
binaryMatrixHMRTurkey <- binaryMatrixHMRTurkey[,!colSums(is.na(binaryMatrixHMRTurkey)) == nrow(binaryMatrixHMRTurkey)]
binaryMatrixHMRTurkey <- binaryMatrixHMRTurkey[!rowSums(is.na(binaryMatrixHMRTurkey)) == ncol(binaryMatrixHMRTurkey),]
# set NA to 0.5 for plotting
binaryMatrixHMRFull <- binaryMatrixHMRTurkey
binaryMatrixHMRFull[is.na(binaryMatrixHMRFull)] <- 0.5

# Heatmap
library(pheatmap)
pheatmap(binaryMatrixHMRTurkey[order(rowMeans(binaryMatrixHMRTurkey, na.rm=TRUE)),], 
         cluster_rows=FALSE, cluster_cols=FALSE,
         show_colnames = FALSE, show_rownames = FALSE,
         na_col="grey")

## Reduced dimension
# We see 2 groups here, which according to me will be artificially created due to different numbers of NAs (and hence 0.5 values in this case).
library(Seurat)
lsiHMRFull <- Seurat::RunLSI(t(binaryMatrixHMRFull), n=10)
lsidr <- Embeddings(lsiHMRFull)
plot(lsidr, 
     col = dayjob::colby(rowMeans(binaryMatrixHMRTurkey, na.rm=TRUE)),
     pch=16)
umdr <- uwot::umap(lsidr)
plot(umdr, 
     col = dayjob::colby(rowMeans(binaryMatrixHMRTurkey, na.rm=TRUE)),
     pch=16)
```


## Arbitrary Binning

```{r}
## arbitrary binning
mean(is.na(binaryMatrixHMRTurkey))
bins <- round(seq(1, ncol(binaryMatrixHMRTurkey), length=120))
binFactor <- factor(c(1, unlist(mapply(rep, 1:(length(bins)-1), each=diff(bins)))))
binBinaryMatrixHMRTurkey <- matrix(NA, nrow=nrow(binaryMatrixHMRTurkey), ncol=nlevels(binFactor))
for(bb in 1:nlevels(binFactor)){
  binBinaryMatrixHMRTurkey[,bb] <- rowMeans(binaryMatrixHMRTurkey[,binFactor == levels(binFactor)[bb]], na.rm = TRUE)
}
pheatmap(binBinaryMatrixHMRTurkey[order(rowMeans(binBinaryMatrixHMRTurkey, na.rm=TRUE)),], 
         cluster_rows=FALSE, cluster_cols=FALSE,
         show_colnames = FALSE, show_rownames = FALSE,
         na_col="grey")

pheatmap(binBinaryMatrixHMRTurkey, 
         cluster_rows=TRUE, cluster_cols=FALSE,
         show_colnames = FALSE, show_rownames = FALSE,
         na_col="grey")

## Reduced dimension
sum(is.na(binBinaryMatrixHMRTurkey))
binBinaryMatrixHMRTurkey[is.na(binBinaryMatrixHMRTurkey)] <- mean(binBinaryMatrixHMRTurkey, na.rm=TRUE)
library(Seurat)
lsiHMRFullBin <- Seurat::RunLSI(t(binBinaryMatrixHMRTurkey), n=10)
lsidrBin <- Embeddings(lsiHMRFullBin)
rmID <- which(MatrixGenerics::rowAnys(is.nan(lsidrBin)))
plot(lsidrBin[-rmID,], 
     col = dayjob::colby(rowMeans(binBinaryMatrixHMRTurkey, na.rm=TRUE)[-rmID]),
     pch=16)


```

## Loess binning

```{r}
### HMR segments
hmrSegments <- readRDS("../../data/segmentsHMR.rds")
readAvMethList <- list()
for(rr in 1:length(readsHMRAll)){
  curRead <- readsHMRAll[rr]
  curData <- binaryCallsHMRAll[binaryCallsHMRAll$readID == curRead,]
  avMethLinkers <- c()
  for(bb in 1:nrow(hmrSegments)){
    curStart <- hmrSegments$start[bb]
    curEnd <- hmrSegments$end[bb]
    curId <- curData$pos >= curStart & curData$pos <= curEnd
    if(sum(curId) > 0){
      curBinData <- curData[curData$pos >= curStart & curData$pos <= curEnd,]
      avMethLinkers[bb] <- mean(curBinData$methylation)
      names(avMethLinkers)[bb] <- nrow(curBinData) #coverage
    } else {
      avMethLinkers[bb] <- NA
    }
  }
  readAvMethList[[rr]] <- avMethLinkers
}

avMethMat <- do.call(rbind, readAvMethList)
colSums(is.na(avMethMat)) # sometimes no data in defined bins
# focus on 838 reads with data in all bins
readAvMethListComplete <- avMethMat[rowSums(is.na(avMethMat)) == 0,]

# cluster reads only
pheatmap(readAvMethListComplete, 
         cluster_rows=TRUE, cluster_cols=FALSE,
         show_colnames = FALSE, show_rownames = FALSE)
# cluster reads and bins
pheatmap(readAvMethListComplete, 
         cluster_rows=TRUE, cluster_cols=TRUE,
         show_colnames = FALSE, show_rownames = FALSE)
# order rows by mean
pheatmap(readAvMethListComplete[order(rowMeans(readAvMethListComplete)),], 
         cluster_rows=FALSE, cluster_cols=FALSE,
         show_colnames = FALSE, show_rownames = FALSE)
# order rows and columns by mean
pheatmap(readAvMethListComplete[order(rowMeans(readAvMethListComplete)),
                                order(colMeans(readAvMethListComplete), decreasing=TRUE)], 
         cluster_rows=FALSE, cluster_cols=FALSE,
         show_colnames = FALSE, show_rownames = FALSE)
```


